% Section 5: Design and Architecture

\section{Design and Architecture}

\subsection{Introduction}

This chapter presents the overall architecture of the system, the main design decisions taken, the technologies and tools used, and the UML diagrams that describe the internal structure and behaviour of the system. The objective is to ensure the system is modular, scalable, maintainable, and aligned with the requirements defined in the previous chapter.

\subsection{System Architecture}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth,keepaspectratio]{rapport/media/communication_diag.png}
\caption{Detailed System Flow}
\label{fig:systemflow}
\end{figure}

\subsection{Database Design}

% A3 landscape page for database diagram
\clearpage
\newgeometry{paperwidth=420mm,paperheight=297mm,margin=1cm}
\begin{landscape}
\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth,height=0.95\textheight,keepaspectratio]{rapport/media/erd.png}
\caption{Complete Database Design and ER Diagram}
\label{fig:erdatabase}
\end{figure}
\end{landscape}
\restoregeometry
\clearpage
% Return to normal A4 format

\subsection{Design Principles}

Throughout the design process, I adhered to fundamental software engineering principles that I believe are essential for building maintainable systems. Modularity was paramount -- I divided code into reusable components and services so that changes in one area wouldn't cascade through the entire system. Separation of concerns guided my architectural decisions, keeping frontend presentation logic, backend business logic, and data persistence cleanly separated. This makes reasoning about the system much easier and allows team members to work on different layers without stepping on each other's toes. Security by design wasn't an afterthought; I architected the system from the ground up with security in mind, ensuring all API calls are authenticated and sensitive data is encrypted both in transit and at rest. Scalability was a key consideration because I've seen too many systems that work beautifully at small scale but collapse under real-world load. By separating backend and database services, I designed ErrorZen to scale horizontally, adding more instances as demand grows rather than being limited by single-server constraints.

\subsection{Product Backlog}

The product backlog was organized into 7 main epics, each containing multiple user stories distributed across the project sprints:

\begin{table}[H]
\centering
\caption{Product Backlog Summary by Epic}
\footnotesize
\begin{tabular}{|p{4cm}|p{2cm}|p{7cm}|}
\hline
\textbf{Epic} & \textbf{Sprint} & \textbf{Key User Stories} \\ \hline
Backend \& Data Auth & 1 & Setup Go/gRPC backend, PostgreSQL with WAL, Authentication UI, RBAC implementation \\ \hline
Real-Time Error Capture & 2 & Dashboard metrics UI, Error/Logs UI, API development, Backend integration \\ \hline
DevOps Foundation & 3 & Pipeline dashboard, API development, CI/CD tools, Pipeline automation \\ \hline
Error Classification \& AI Fixes & 4 & AI model integration, Error tagging, Automated fixes, Unit test generation \\ \hline
Alerting \& Notifications & 5 & Tool integrations, Notification system, Billing alerts, Alert throttling \\ \hline
Data Protection \& Payments & 6 & AES-256 encryption, GDPR compliance, Usage computation, Payment services \\ \hline
SDKs \& Plugins & 7 & Node.js plugin, Flutter/Dart SDK, Service activation, Documentation \\ \hline
\end{tabular}
\end{table}

The complete backlog contained 35 user stories with estimated efforts ranging from 8 to 24 hours per story, totaling approximately 420 hours of development work across the 7 sprints.

\subsection{Summary}

This chapter captures the architectural thinking and design decisions that shaped ErrorZen. Every technology choice I made was deliberate, balancing development speed against scalability and long-term maintainability. I didn't want to build something that works today but becomes a maintenance nightmare tomorrow. The UML diagrams and ER models I created weren't just academic exercises -- they served as blueprints that guided implementation decisions and helped me communicate the system's structure to stakeholders. Having this clear technical foundation made the actual coding phase more focused because the big architectural questions were already answered.